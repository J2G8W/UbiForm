<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UbiForm: Library plan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UbiForm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Library plan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Below documents the central classes I plan to implement. This has scope to be changed, but allows me to plan as I start writing stuff. I believe it encompasses the key functionality that is required at the time of writing.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Parts of the component</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Component::</h2>
<p>The point of this class is to represent the whole object we are running on. The expectation is that anything using my software will only use one Component object to run</p>
<div class="fragment"><div class="line">specifyManifest(FILE *)`</div>
<div class="line">specifyManifest(char *jsonString)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>For our component we present raw data to build the manifest object which describes it. The Component then OWNS the manifest object (and is reponsible for deletion) </p>
</blockquote>
<p><code>void createNewPairEndpoint(std::string type, std::string id)</code> </p><blockquote class="doxtable">
<p>This function will create a new PairEndpoint which we can use. It stores the endpoint internally, and we can return it using other functions. The type refers to which type is specified in our manifest (details at the bottom of the document) and the id refers to the local id of the endpoint within the component. (We can have lots of endpoints of the same type, but with different ids) </p>
</blockquote>
<div class="fragment"><div class="line">DataReceiverEndpoint *getReceiverEndpoint(const std::string &amp;id)</div>
<div class="line">DataSenderEndpoint *getSenderEnpoint(const std::string &amp;id)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>We return an endpoint from our component's data set. This can then be operated on using the functions presented by our different endpoints. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md4"></a>
ComponentManifest::</h2>
<p>This is used to specify the description of a component. It contains a schema for each endpoint that the component can have. </p><div class="fragment"><div class="line">ComponentManifest (const char *)</div>
<div class="line">ComponentManifest (FILE *)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>Our constructors from string and file pointer. The structure of the input JSON is described elsewhere. </p>
</blockquote>
<p><code>std::string stringify()</code> </p><blockquote class="doxtable">
<p>Returns a string version of our manifest which can be sent on networks etc </p>
</blockquote>
<div class="fragment"><div class="line">EndpointSchema *getReceiverSchema(const std::string&amp; typeOfEndpoint)</div>
<div class="line">EndpointSchema *getSenderSchema(const std::string &amp;typeOfEndpoint)</div>
</div><!-- fragment --><p> &gt;These methods will return pointers to our endpoint schemas given the typeOfEndpoint. They could be combined into a single function call with a boolean differentiater, but I feel this over complicates things</p>
<p><b>METHODS TO CHANGE INDIVIDUAL EndpointSchema - further research is needed into exactly what I want to allow to change</b></p>
<p><code>void changeAttributeType( std::string &amp;AttributeName, TYPE)</code> </p><blockquote class="doxtable">
<p>We change the type of an attribute </p>
</blockquote>
<p><code>void addRequired(std::string &amp;AttributeName)</code> </p><blockquote class="doxtable">
<p>We specify that the attribute name is requried </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md5"></a>
Endpoints</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
(ABSTRACT) DataReceiverEndpoint::</h2>
<p>The point of this class, is to represent something which receives data from a source. It is designed to always be the iniator of the conversation (dialer)</p>
<p><code>DataReceiverEndpoint(EndpointSchema*)</code> </p><blockquote class="doxtable">
<p>We create the Endpoint by giving it a pointer to the schema it will be using. Becuase it is a pointer we are able to change the underlying schema from above it. The Endpoint is <b>not responsible</b> for memory management of the schema. </p>
</blockquote>
<p><code>virtual void dialConnection (const char* url)</code> </p><blockquote class="doxtable">
<p>This is implemented differently in each extending class, but has the concept of dialling something at the given URL </p>
</blockquote>
<p><code>unique_ptr&lt;SocketMessage&gt; receiveMessage()</code> </p><blockquote class="doxtable">
<p>Receive message on whatever socket we have opened - blocking. This SocketMessage has a unique pointer, so memory management is easier here. </p>
</blockquote>
<p><code>void receiveAsyncMessage (HandlerFunction)</code> </p><blockquote class="doxtable">
<p>Receive message on whatever socket we have opened - non-blocking. We take in a function to handle the message rather than return the message as it by definition async </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md7"></a>
(ABSTRACT) DataSenderEndpoint::</h2>
<p>The point of this class, is to represent something which sends data to a source. It is designed to always be the reciver of the call to start. I.e. there has been some sort of request to it for info</p>
<p><code>DataSenderEndpoint(EndpointSchema*)</code> </p><blockquote class="doxtable">
<p>We create the Endpoint by giving it a pointer to the schema it will be using. Becuase it is a pointer we are able to change the underlying schema from above it. The Endpoint is <b>not responsible</b> for memory management of the schema. </p>
</blockquote>
<p><code>virtual void listenForConnection(const char *url)</code> </p><blockquote class="doxtable">
<p>This is implemented differently in each extending class, but has the concept of listening for something at the given local URL </p>
</blockquote>
<p><code>void sendMessage(SocketMessage)</code> </p><blockquote class="doxtable">
<p>Sends message on whatever socket we have opened - blocking </p>
</blockquote>
<p><code>void sendAsyncMessage(SocketMessage)</code> </p><blockquote class="doxtable">
<p>Send message on whatever socket we have opened - non- blocking </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md8"></a>
PairEndpoint:: (extends DataReceivingEndpoint, DataSendingEndpoint)</h2>
<p>This gives the ability for each endpoint to send and receiver data (using the same underlying socket)</p>
<p><code>PairEndpoint(EndpointSchema * receiveSchema, EndpointSchema * sendSchema)</code> </p><blockquote class="doxtable">
<p>This will create a new PairEndpoint based on the given schemas. Note that this will likely be private such that this can only be made via the <b>Component</b> interface. </p>
</blockquote>
<p><code>void listenForConnection(const char *url) override</code> </p><blockquote class="doxtable">
<p>This implements the required method </p>
</blockquote>
<p><code>void dialConnection(const char *url) override</code> </p><blockquote class="doxtable">
<p>This implements the required method </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md9"></a>
PublisherEndpoint:: (extends DataSenderEndpoint)</h2>
<p>This does the Publisher bit of the Pub/Sub model</p>
<p><code>PublisherEndpoint(EndpointSchema * sendSchema)</code> </p><blockquote class="doxtable">
<p>This will create a new PublisherEndpoint based on the given schemas. Note that this will likely be private such that this can only be made via the <b>Component</b> interface. </p>
</blockquote>
<p><code>void listenForConnection(const char *url) override</code> </p><blockquote class="doxtable">
<p>This implements the required method </p>
</blockquote>
<p><b>May or may not implement this, it is extra</b></p>
<p><code>void sendMessageOfTopic(SocketMessage, TopicRepresentation)</code> </p><blockquote class="doxtable">
<p>Used by the Publisher endpoint to send a message of a specific TopicRepresentation </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md10"></a>
SubscriberEndpoint:: (extends DataReceiverEndpoint)</h2>
<p>This does the Subscriber bit of the Pub/Sub model</p>
<p><code>SubscriberEndpoint(EndpointSchema * receiveSchema)</code> </p><blockquote class="doxtable">
<p>This will create a new SubscriberEndpoint based on the given schema. Note that this will likely be private such that this can only be made via the <b>Component</b> interface. </p>
</blockquote>
<p><code>void dialConnection(const char *url) override</code> </p><blockquote class="doxtable">
<p>This implements the required method </p>
</blockquote>
<p>** May or may not implement this, it is extra ** <code>void specifyTopics( TopicRepresentation)</code> </p><blockquote class="doxtable">
<p>This will be used by the Subscriber endpoint to specify which topics they want to listen in on </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md11"></a>
ResourceDiscoveryEndpoint:: (Extends SomeEndpoint)</h2>
<p>Each component will likely have an endpoint of this type such that it has the ability to connect to the ResourceDiscoveryComponent and make requests</p>
<p><code>void connectToRDC()</code> </p><blockquote class="doxtable">
<p>We will use <b>some as yet undecided technique</b> to find the RDC on the network we are currently on. This will establish the connection with the RDC component </p>
</blockquote>
<p><code>??? findAvailableConnections(EndpointSchema)</code> </p><blockquote class="doxtable">
<p>We make a request to the RDC to find available connections on the network which can relate to our Manifest. We then return this in some form of data structure. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md12"></a>
MutatorEndpoint (extends PairEndpoint)</h2>
<p>We want to send and receive changes which will change the manifest of our components.</p>
<p><b>Will have very similar methods to the mutator methods for the ComponentManifest, these are TBC so I won't have any more depth here</b></p>
<h1><a class="anchor" id="autotoc_md13"></a>
Other bookkeeping</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
SocketMessage::</h2>
<p>This is used to describe a message which we'll send on the socket.</p>
<p><code>SocketMessage()</code> <code>Socket Message(const char*)</code> </p><blockquote class="doxtable">
<p>We have two constructors, a default one creates the empty message, and the string ne will initialise a message from an input string. </p>
</blockquote>
<div class="fragment"><div class="line">void addMember(std::string &amp;attributeName, int value)</div>
<div class="line">void addMember(std::string &amp;attributeName, bool value)</div>
<div class="line">void addMember(std::string &amp;attributeName, std::string value)</div>
<div class="line">void addMember(std::string &amp;attributeName, std::vector&lt;T&gt; value)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>We add members to our socket message. This will include replacement so if you try and add two attributes of the same name, the most recent value is kept. </p>
</blockquote>
<div class="fragment"><div class="line">int getInteger(std::string &amp;attributeName)</div>
<div class="line">bool getBoolean(std::string &amp;attributeName)</div>
<div class="line">std::string getString(std::string &amp;attributeName)</div>
<div class="line">????? getArray(std::string &amp;attributeName)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>We have getter methods for our socket message so we can manipulate the data on the other end. The array is a challenge to represent as we wanted to have the ability to do nesting </p>
</blockquote>
<p><code>std::string stringify()</code> </p><blockquote class="doxtable">
<p>Is used to return a string of our message such that it can be sent on the network </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md15"></a>
EndpointSchema</h2>
<p>This is used to describe schema for a given endpoint. It uses JSON schema to describe what data it can accept/send and means we can validate incoming messages against it. It is largely a wrapper class around our rapidjson object.</p>
<p><code>EndpointSchema(rapidjson::Value &amp;doc) :</code> </p><blockquote class="doxtable">
<p>Initialises out object. This method will likely be private such that they can only be initialised through the Component class </p>
</blockquote>
<p><code>void validate(const SocketMessage &amp;messageToValidate)</code> </p><blockquote class="doxtable">
<p>This checks our schema against the given SocketMessage and throws an exception if there are any errors. The type of exception thrown will be clarified. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
